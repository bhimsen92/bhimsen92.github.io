<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blog</title>
    <link href="/static/css/main.css" rel="stylesheet" />
    <link href="/static/css/default.min.css" rel="stylesheet" />
    <script src="/static/js/highlight.min.js"></script>
  </head>
  <body
    class="bg-gray-100 container mx-auto font-sans leading-normal tracking-normal"
  >
    <!-- Navigation bar -->
    <nav class="p-4 border-b-4 border-b-orange-700">
      <div class="flex justify-between items-center">
        <div class="flex items-center space-x-4">
          <a href="/">
            <span class="text-lg font-bold font-mono">Blog</span>
          </a>
          <a href="/">Posts</a>
        </div>
        <a href="/about.html">About</a>
      </div>
    </nav>

    
  <!-- Main content -->
  <div class="container mx-auto flex-grow">
    <!-- Blog post -->
    <article class="bg-white rounded-lg shadow-md p-8">
      <h1 class="text-3xl font-semibold text-gray-900 mb-4">
        
  Python Metaclass and It's Magic Methods

      </h1>

      <!-- Post metadata -->
      

      <div class="max-w-6xl prose text-justify">
        
  <!-- Post Content -->
  
            <p class="my-4 text-lg">
    Metaclasses are a very confusing and complicated topic in python, well at
    least for me. Everything seems clear when I am reading this topic but I
    forget after a few days. So I thought it is better to blog about my
    understanding so that this concept always stays with me.
  </p>
        

  
            <p class="my-4 text-lg">
    A
    <code>metaclass</code>
    is nothing but a class of a class. In python everything is an object,
    including
    <code>class</code>
    . Python’s built-in function
    <code>type</code>
    is responsible for creating new type objects a.k.a classes at runtime. And
    you can verify it yourself by checking the
    <code>__class__</code>
    property type.

<pre class="bg-gray-100 rounded p-4 overflow-auto"><code class="python">>>class A:
>>   pass
>>A.__class__
>>type</code></pre>

    A type function when supplied with one argument, returns the type of the object which is nothing but its class. 
    If you supply 3 arguments, it creates a new <code>type</code> i.e class at runtime.


<pre class="bg-gray-100 rounded p-4 overflow-auto"><code class="python">>>class A:
>>    pass
>>a = A()
>>type(a)
>>__main__.A
>>B = type(‘B’, (), {“a”: 2}) // name, bases, attributes
>>B.a
>>2</code></pre>

    So you can see that class definition is just a syntactic sugar for
    <code>type</code>
    call at runtime which is invoked when the interpreter parses the class
    definition.
  </p>
        

  
            <p class="my-4 text-lg">
    Python allows us to customize the class construction behaviour by
    subclassing
    <code>type</code>
    class and overriding certain magic methods, namely: “__new__, __init__,
    __call__, __prepare__”. Once this custom metaclass is defined, we can let
    the new classes use this new metaclass by passing it as an argument in class
    definition using “metaclass” arguments. Before we understand how the
    aforementioned magic methods work in the case of metaclass, let's understand
    how they work in normal classes.
  </p>
        

  
            <p class="my-4 text-lg">
    Explain the magic methods using normal classes Let's understand the order of
    their method execution before we look at a simple example. Method
    “__prepare__” is only applicable when the class is a metaclass(explained
    later). So we will focus on “__new__, __init__, __call__” methods.
    <br><br> Each of the above methods receive the same arguments as the
    constructor, except for __call__. __new__: It is called before an instance
    of a class is created. That is, when you try to instantiate a class. It is
    the first method that is invoked of the magic methods that were mentioned
    earlier. <br><br> It is a static class where the first argument is the
    class whose object will be created. The rest are the arguments passed to the
    constructor. This method must return the object created, otherwise
    “__init__” won’t be called next. __init__: We are all familiar with this
    method call. Called to initialize the object. It is the second method called
    right after the “new” method call. Returns the nothing __call__: This is
    invoked when an instance of the method is called as a function. Typically
    needed when a function/service requires a callable object. Probably needed
    when you want stateful functions. It receives the argos that are supplied
    when the object is called. <br><br> Let’s try to implement the
    “Singleton” class using the above magic methods. To make sure that only one
    instance of a class exists at any moment of time, we need to intercept the
    object creation step so that just before an object is created, we will check
    if the object already exists. If it does, return that otherwise create it,
    store it in a map, and return the object.
  </p>
        

      </div>

      <a href="/posts" class="text-blue-500 hover:underline">Back to Posts</a>
    </article>
  </div>


    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>